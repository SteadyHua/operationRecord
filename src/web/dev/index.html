<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>测试页面</title>
    <link rel="icon" href="./favicon-32x32.png" type="image/png" />
    <script type="text/javascript" src="operationRecord.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      canvas {
        width: 100%;
        height: 400px;
      }
    </style>
  </head>
  <body>
    <video controls src="" width="200"></video>
    <canvas id="c" height="400"></canvas>
    <script>
      const video = document.querySelector("video");
      const c = document.querySelector("#c");
      const gl = c.getContext("webgl");
      const or = new OperationRecord({
        onStartREC(stream) {
          video.srcObject = stream;
          console.log("执行", stream);
        },
      });
      // 顶点着色器代码(决定顶在哪里，大小)
      const VSHADER_SOURCE =
        "attribute vec4 a_Position;\n" +
        "void main() {\n" +
        "  gl_Position = a_Position;\n" + // 设置顶点的位置
        "  gl_PointSize = 3.0;\n" + // 设置顶点的大小
        "}\n";

      // 片元着色器代码（给像素上色）
      const FSHADER_SOURCE =
        "void main() {\n" +
        "  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n" + // 设置顶点的颜色
        "}\n";

      function main() {
        const program = createProgram(gl, VSHADER_SOURCE, FSHADER_SOURCE);
        gl.program = program;
        gl.useProgram(program);

        const n = initVertexBuffers(gl);

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        // 每一次重绘时的背景色
        gl.clearColor(0.0, 0.0, 0.0, 1.0);

        // 清除 <canvas>
        gl.clear(gl.COLOR_BUFFER_BIT);
        // 画n个点
        gl.drawArrays(gl.POINTS, 0, n);
      }
      function initVertexBuffers(gl) {
        const n = 10000;
        const vertices = new Float32Array(
          Array.from({ length: n * 2 }, () => {
            return Math.random() * (Math.random() > 0.5 ? 1 : -1);
          })
        );

        // 创建一个缓存对象，用于存放顶点数据
        const vertexBuffer = gl.createBuffer();
        // 绑定缓存对象
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        // 把数据写到缓冲对象中
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        // 获取顶点着色器代码中的顶点变量
        const a_Position = gl.getAttribLocation(gl.program, "a_Position");
        console.log(a_Position);
        // 设置变量获取数据规则
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
        // 允许变量从 ARRAY_BUFFER目标上绑定的缓冲区对象获取数据
        gl.enableVertexAttribArray(a_Position);

        return n;
      }

      // 创建一个program（相当于着色器的上下文）
      function createProgram(gl, vshader, fshader) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);

        gl.linkProgram(program);
        return program;
      }
      function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
      }
      resize();
      main();
      window.addEventListener("resize", resize);

      function resize() {
        c.width = document.body.clientWidth;
      }
    </script>
  </body>
</html>
